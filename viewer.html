<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>RADIORUM — Viewer</title>
  <style>
    :root{ --yellow:#FFD700; --black:#000; --gray:#E0E0E0; }
    body,html{ margin:0; height:100%; font-family:Arial, sans-serif; background:var(--gray); color:var(--black); }
    header{ background:var(--black); color:var(--yellow); padding:12px 16px; display:flex; align-items:center; gap:12px; }
    #container{ width:100%; height:calc(100vh - 64px); }
    #controls{ position:absolute; left:12px; top:72px; z-index:3; background:rgba(255,255,255,0.95); padding:10px; border-radius:8px; box-shadow:0 2px 8px rgba(0,0,0,0.15); }
    .btn{ background:var(--black); color:var(--yellow); border:none; padding:6px 10px; border-radius:6px; cursor:pointer; }
  </style>
</head>
<body>
  <header>
    <div style="width:40px;height:40px;background:var(--yellow);border-radius:6px;display:flex;align-items:center;justify-content:center;font-weight:700;color:var(--black)">R</div>
    <div>
      <div style="font-weight:700">RADIORUM</div>
      <div style="font-size:12px">Visualizador 3D — Caso: {{case_id}}</div>
    </div>
    <div style="margin-left:auto;">
      <a href="/" class="btn">⬅ Upload</a>
    </div>
  </header>

  <div id="controls">
    <div>
      <label>Threshold: <span id="thval">0.50</span></label><br>
      <input id="threshold" type="range" min="0" max="1" step="0.01" value="0.5" style="width:220px">
      <button id="apply" class="btn">Aplicar</button>
      <button id="reset" class="btn" style="margin-left:6px">Reset</button>
    </div>
    <div style="margin-top:8px; font-size:12px; color:#333">Dica: ajuste o threshold para realçar superfícies (0-1).</div>
  </div>

  <div id="container"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r150/three.min.js"></script>
  <script>
    const caseId = "{{case_id}}";
    const meshEndpoint = `/mesh/${caseId}.json`;
    let scene, camera, renderer, mesh;

    function init(){
      scene = new THREE.Scene();
      const w = window.innerWidth, h = window.innerHeight;
      camera = new THREE.PerspectiveCamera(60, w/h, 0.1, 10000);
      camera.position.set(0,0,200);
      renderer = new THREE.WebGLRenderer({antialias:true});
      renderer.setSize(w,h);
      document.getElementById('container').appendChild(renderer.domElement);

      const light = new THREE.DirectionalLight(0xffffff,1);
      light.position.set(1,1,1).normalize();
      scene.add(light);
      scene.add(new THREE.AmbientLight(0x444444));

      window.addEventListener('resize', ()=>{
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      loadMesh(0.5);
    }

    async function fetchMesh(th){
      const url = meshEndpoint + '?threshold=' + th;
      const resp = await fetch(url);
      if(!resp.ok){ alert('Falha ao obter mesh'); return null;}
      return await resp.json();
    }

    async function loadMesh(th){
      const meshData = await fetchMesh(th);
      if(!meshData) return;
      addMeshToScene(meshData);
    }

    function addMeshToScene(meshData){
      if(mesh){ scene.remove(mesh); mesh.geometry.dispose(); mesh.material.dispose(); }
      const verts = meshData.vertices;
      const faces = meshData.faces;
      const geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(verts.length * 3);
      for(let i=0;i<verts.length;i++){
        positions[i*3+0]=verts[i][0];
        positions[i*3+1]=verts[i][1];
        positions[i*3+2]=verts[i][2];
      }
      // choose index array type based on size
      const idx = (verts.length > 65535) ? Uint32Array : Uint16Array;
      const indices = new idx(faces.length * 3);
      for(let i=0;i<faces.length;i++){
        indices[i*3+0]=faces[i][0];
        indices[i*3+1]=faces[i][1];
        indices[i*3+2]=faces[i][2];
      }
      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.setIndex(new THREE.BufferAttribute(indices, 1));
      geometry.computeVertexNormals();

      const material = new THREE.MeshStandardMaterial({metalness:0.2, roughness:0.8, side: THREE.DoubleSide});
      mesh = new THREE.Mesh(geometry, material);
      geometry.computeBoundingBox();
      const bb = geometry.boundingBox;
      const center = new THREE.Vector3();
      bb.getCenter(center);
      mesh.position.sub(center);
      scene.add(mesh);
      fitCameraToObject(camera, mesh, 1.2);
      animate();
    }

    function fitCameraToObject(camera, object, offset = 1.25){
      const boundingBox = new THREE.Box3().setFromObject(object);
      const center = new THREE.Vector3();
      boundingBox.getCenter(center);
      const size = boundingBox.getSize(new THREE.Vector3());
      const maxDim = Math.max(size.x, size.y, size.z);
      const fov = camera.fov * (Math.PI / 180);
      let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2)) * offset;
      camera.position.set(center.x, center.y, cameraZ + center.z);
      camera.lookAt(center);
      camera.updateProjectionMatrix();
    }

    function animate(){
      requestAnimationFrame(animate);
      if(mesh) mesh.rotation.y += 0.0025;
      renderer.render(scene, camera);
    }

    document.getElementById('threshold').addEventListener('input', (e)=>{
      document.getElementById('thval').innerText = parseFloat(e.target.value).toFixed(2);
    });
    document.getElementById('apply').addEventListener('click', async ()=>{
      const t = document.getElementById('threshold').value;
      document.getElementById('apply').disabled = true;
      await loadMesh(t);
      document.getElementById('apply').disabled = false;
    });
    document.getElementById('reset').addEventListener('click', ()=>{ document.getElementById('threshold').value=0.5; document.getElementById('thval').innerText='0.50'; loadMesh(0.5); });

    init();
  </script>
</body>
</html>
